/*

 Raptor Interpreter engine

 Copyright (C) 2013  Luca Magistrelli <blackstorm010[at]gmail[dot]com>

 Based on ZemScript interpreter by Cameron Zemek Copyright (c) 2008 grom[at]zeminvaders[dot]net

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/
package it.raptor.lang;

import it.raptor.lang.ast.RootNode;
import it.raptor.lang.runtime.ArrayPushFunction;
import it.raptor.lang.runtime.ExitFunction;
import it.raptor.lang.runtime.Function;
import it.raptor.lang.runtime.GetUrlVulnFunction;
import it.raptor.lang.runtime.HttpDownloadFunction;
import it.raptor.lang.runtime.IsNullFunction;
import it.raptor.lang.runtime.LenFunction;
import it.raptor.lang.runtime.PrintFunction;
import it.raptor.lang.runtime.PrintLineFunction;
import it.raptor.lang.runtime.RegexSearchFunction;
import it.raptor.lang.runtime.ReturnFailedFunction;
import it.raptor.lang.runtime.ReturnSuccessFunction;
import it.raptor.lang.runtime.ReturnUrlVulnFunction;
import it.raptor.lang.runtime.StringSearchFunction;
import it.raptor.lang.runtime.StringSplitFunction;
import it.raptor.lang.runtime.ZemObject;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Interpreter directly evaluates the abstract syntax tree generated by the
 * Parser. It checks the semantics as it process the tree.
 *
 */
public class Interpreter {
    /**
     * Map of variables to their objects
     */
    private Map<String, ZemObject> symbolTable = new HashMap<String, ZemObject>();

    /**
     * Setup interpreter with empty symbol table
     * and register built-in functions.
     */
    public Interpreter() {
        // Register built-in functions
        symbolTable.put("print", new PrintFunction());
        symbolTable.put("println", new PrintLineFunction());
        symbolTable.put("len", new LenFunction());
        symbolTable.put("array_push", new ArrayPushFunction());
        symbolTable.put("http_download_page", new HttpDownloadFunction());
        symbolTable.put("regex_search", new RegexSearchFunction());
        symbolTable.put("string_search", new StringSearchFunction());
        symbolTable.put("return_url_vuln", new ReturnUrlVulnFunction());
        symbolTable.put("return_success", new ReturnSuccessFunction());
        symbolTable.put("return_failed", new ReturnFailedFunction());
        symbolTable.put("get_url_vuln", new GetUrlVulnFunction());
        symbolTable.put("string_split", new StringSplitFunction());
        symbolTable.put("isNull", new IsNullFunction());
        symbolTable.put("exit", new ExitFunction());
    }

    /**
     * Get the current value of a variable.
     *
     * @param name Variable name
     * @param pos  Source position of where the variable is being requested
     * @return The value of the variable
     */
    public ZemObject getVariable(String name, SourcePosition pos) {
        if (!symbolTable.containsKey(name)) {
            throw new UnsetVariableException(name, pos);
        }
        return symbolTable.get(name);
    }

    /**
     * Set the value of a variable
     *
     * @param name  Variable name
     * @param value New value for the variable
     */
    public void setVariable(String name, ZemObject value) {
        symbolTable.put(name, value);
    }

    /**
     * Check that a function exists.
     *
     * @param functionName Function to check.
     */
    public void checkFunctionExists(String functionName, SourcePosition pos) {
        ZemObject symbol = getVariable(functionName, pos);
        if (!(symbol instanceof Function)) {
            throw new InvalidTypeException(functionName + " is not a function", pos);
        }
    }

    /**
     * Call a function.
     *
     * @param functionName The function to call
     * @param args List of arguments to pass to function
     * @return Return value from function
     */
    public ZemObject callFunction(String functionName, List<ZemObject> args, SourcePosition pos) {
        Function function = (Function) symbolTable.get(functionName);
        // Save the symbolTable
        Map<String, ZemObject> savedSymbolTable =
            new HashMap<String, ZemObject>(symbolTable);
        // Setup symbolTable for function
        int noMissingArgs = 0;
        int noRequiredArgs = 0;
        for (int paramIndex = 0;
                paramIndex < function.getParameterCount(); paramIndex++) {
            String parameterName = function.getParameterName(paramIndex);
            ZemObject value = function.getDefaultValue(paramIndex);
            if (value == null) {
                noRequiredArgs++;
            }
            if (paramIndex < args.size()) {
                // Value provided in function call overrides the default value
                value = args.get(paramIndex);
            }
            if (value == null && functionName.compareToIgnoreCase("isNull") != 0) {
                noMissingArgs++;
            }
            setVariable(parameterName, value);
        }
        if (noMissingArgs > 0) {
            throw new TooFewArgumentsException(functionName, noRequiredArgs,
                    args.size(), pos);
        }
        ZemObject ret = function.eval(this, pos);
        // Restore symbolTable
        symbolTable = savedSymbolTable;

        return ret;
    }

    /**
     * Evaluate script
     *
     * @param script The script to evaluate
     * @return The exit status
     * @throws IOException
     */
    public ZemObject eval(String script) throws IOException {
        return eval(new StringReader(script));
    }

    /**
     * Evaluate script
     *
     * @param file The file that contains the script
     * @return The exit status
     * @throws IOException
     */
    public ZemObject eval(File file) throws IOException {
        return eval(new BufferedReader(new FileReader(file)));
    }

    /**
     * Evaluate script
     *
     * @param reader The reader that contains the script
     * @return The exit status
     * @throws IOException
     */
    public ZemObject eval(Reader reader) throws IOException {
        Lexer lexer = new Lexer(reader);
        Parser parser = new Parser(lexer);
        RootNode program = parser.program();
        return program.eval(this);
    }
    
    
}
